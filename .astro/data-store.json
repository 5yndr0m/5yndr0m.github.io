[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.17.1","content-config-digest","86f543bc85960af9","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false,\"svgo\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12],"decoding-the-wire",{"id":11,"data":13,"body":19,"filePath":20,"assetImports":21,"digest":25,"rendered":26,"legacyId":67},{"title":14,"description":15,"pubDate":16,"heroImage":17,"category":18},"Decoding the Wire: How I Built a Raw Socket Sniffer in Python","In an era of encrypted traffic and high-level APIs, the actual mechanics of how data moves across a wire can feel like \"magic.\" To demystify this, I built NetSniff—a low-level network monitor that bypasses the standard OS abstractions to see the raw binary heartbeat of a network.",["Date","2026-02-04T00:00:00.000Z"],"__ASTRO_IMAGE_../../assets/thumbnails/decoding_the_wire.png","Linux","In an era of encrypted traffic and high-level APIs, the actual mechanics of how data moves across a wire can feel like \"magic.\" To demystify this, I built **NetSniff**—a low-level network monitor that bypasses the standard OS abstractions to see the raw binary heartbeat of a network.\n\n![OSI Model Layers](../../assets/blog/OSI_Model_Layers.excalidraw.png)\n\n## What exactly is a \"Sniffer\"?\n\nA network sniffer (or packet analyzer) is a tool that intercepts and logs traffic passing over a digital network. While most applications only see the \"payload\" (the message you sent), a sniffer sees the **envelope, the stamps, and the postmarks.** By putting the network interface into a mode where it captures every frame—not just the ones addressed to your computer—we can visualize the conversation between every device on the local link.\n\n---\n\n## The Anatomy of the Network \"Onion\"\n\nTo build NetSniff, I had to treat every packet like a Russian Nesting Doll. This is known as **Encapsulation**. My code performs **De-encapsulation** in reverse order:\n\n### 1. The Ethernet Frame (The Outer Shell)\n\nEvery piece of data on a local area network (LAN) is wrapped in an Ethernet frame. It’s the \"hardware\" layer.\n\n- **MAC Addresses:** These are the permanent physical IDs of your network card.\n- **The EtherType:** This is a crucial 2-byte field. It tells my sniffer: \"Hey, the next layer inside me is an IPv4 packet\" (Value `8`) or \"This is an ARP request\" (Value `2054`).\n\n### 2. The IP Packet (The Routing Layer)\n\nOnce we peel back the Ethernet header, we find the **Internet Protocol (IP)** packet. This is the \"envelope\" used to move data across the wider internet.\n\n- **IP Addresses:** The logical Source and Destination (e.g., `192.168.1.1`).\n- **TTL (Time to Live):** A counter that prevents packets from looping forever.\n- **Protocol Field:** Just like the EtherType, this tells us what’s inside the IP packet—TCP, UDP, or ICMP.\n\n### 3. The Transport Protocols (The Engines)\n\nThis is where the actual \"work\" happens. NetSniff is designed to handle the \"Big Three\":\n\n- **TCP (Transmission Control Protocol):** The \"Reliable\" one. It uses a 3-way handshake. My code extracts **Flags** (URG, ACK, PSH, RST, SYN, FIN) to show if a connection is starting, ending, or resetting.\n- **UDP (User Datagram Protocol):** The \"Fast\" one. No handshakes, just raw data. Great for streaming or DNS.    \n- **ICMP (Internet Control Message Protocol):** The \"Diagnostic\" one. This is what `ping` uses to check if a server is alive.\n\n---\n\n## Flow: Code Architecture\n\n![NetSniff Flow](../../assets/blog/NetSniff_Flow.excalidraw.png)\n\n---\n## Technical Hurdles: Bitwise Operations\n\nOne of the most challenging parts of this project was dealing with **Network Byte Order (Big Endian)**. Computers store data differently than networks transmit it.\n\nI used Python's `struct` module to map binary data to variables. For example, the IP version and Header Length are crammed into a single byte. To separate them, I had to use **Bitwise Shifting**:\n\n```\nversion_header_length = data[0]\nversion = version_header_length >> 4  # Shift right 4 bits to get the version\nheader_length = (version_header_length & 15) * 4  # Use a mask to get the length\n```\n\n---\n\n## Intelligent Data Handling: The Buffer System\n\nWriting to a CSV file is a \"slow\" operation for a computer. If your network is busy, the sniffer might miss a packet while it's busy writing the previous one to the disk.\n\nTo solve this, I implemented a **Buffer Strategy**:\n\n1. **List Storage:** Packets are held in a memory-resident list.\n2. **Batch Processing:** Only when the list hits 50 packets does the `pandas` library trigger a write to the CSV.\n3. **Schema Consistency:** Since an ARP packet has different fields than a TCP packet, I used a `base_fields` dictionary to ensure the CSV columns stay perfectly aligned, even when data is missing.\n\n---\n\n## Quick Start Guide\n\nWant to try NetSniff yourself? Follow these steps:\n\n1. **Clone:** clone the repository from **[GitHub](https://github.com/5yndr0m/netsniff)**\n2. **Environment:** Create a virtual environment to keep your system clean.\n```bash\npython -m venv venv\nsource venv/bin/python  # On Linux\n```\n    \n2. **Script:** Copy the `netsniff.py` into the virtual environment.  \n3. **Dependencies:** You'll need `pandas` for the data export.  \n```bash\npip install pandas\n```\n    \n4. **Execution:** Because we are touching Raw Sockets, you **must** use `sudo`.\n```bash\nsudo ./venv/bin/python netsniff.py\n```\n\n5. **Logs:** To get terminal logs you can add `--verbose` flag.\n```bash\nsudo ./venv/bin/python netsniff.py --verbose\n```\n\n7. **Output:** Sniffed packets will be saved to the `capture_data.csv` file in the same directory \n\n---\n\n## Troubleshooting & FAQ\n\n- **\"Why do I get Permission Denied?\"**\n    \n    Raw sockets allow you to see traffic from other users and the OS. For security reasons, Linux requires `sudo` or `CAP_NET_RAW` privileges to run this.\n    \n- **\"I'm on Windows and it's crashing!\"**\n    \n    This specific implementation uses `AF_PACKET`, which is a Linux-specific socket type. For Windows support, one would typically use `WinPcap` or `Npcap` drivers.\n    \n- **\"Why is the CSV empty?\"**\n    \n    The sniffer waits for 50 packets before saving. If your network is quiet, try browsing a few websites to generate traffic, or hit `Ctrl+C` to force a final save of the remaining buffer.\n    \n\n---\n\n**This project was a deep dive into the \"low level\" of the web. What should I sniff next? Maybe an HTTP traffic decrypter?**","src/content/blog/Decoding the Wire.md",[22,23,24],"../../assets/blog/OSI_Model_Layers.excalidraw.png","../../assets/blog/NetSniff_Flow.excalidraw.png","../../assets/thumbnails/decoding_the_wire.png","4ea34672b775c85b",{"html":27,"metadata":28},"\u003Cp>In an era of encrypted traffic and high-level APIs, the actual mechanics of how data moves across a wire can feel like “magic.” To demystify this, I built \u003Cstrong>NetSniff\u003C/strong>—a low-level network monitor that bypasses the standard OS abstractions to see the raw binary heartbeat of a network.\u003C/p>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/blog/OSI_Model_Layers.excalidraw.png&#x22;,&#x22;alt&#x22;:&#x22;OSI Model Layers&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Ch2 id=\"what-exactly-is-a-sniffer\">What exactly is a “Sniffer”?\u003C/h2>\n\u003Cp>A network sniffer (or packet analyzer) is a tool that intercepts and logs traffic passing over a digital network. While most applications only see the “payload” (the message you sent), a sniffer sees the \u003Cstrong>envelope, the stamps, and the postmarks.\u003C/strong> By putting the network interface into a mode where it captures every frame—not just the ones addressed to your computer—we can visualize the conversation between every device on the local link.\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"the-anatomy-of-the-network-onion\">The Anatomy of the Network “Onion”\u003C/h2>\n\u003Cp>To build NetSniff, I had to treat every packet like a Russian Nesting Doll. This is known as \u003Cstrong>Encapsulation\u003C/strong>. My code performs \u003Cstrong>De-encapsulation\u003C/strong> in reverse order:\u003C/p>\n\u003Ch3 id=\"1-the-ethernet-frame-the-outer-shell\">1. The Ethernet Frame (The Outer Shell)\u003C/h3>\n\u003Cp>Every piece of data on a local area network (LAN) is wrapped in an Ethernet frame. It’s the “hardware” layer.\u003C/p>\n\u003Cul>\n\u003Cli>\u003Cstrong>MAC Addresses:\u003C/strong> These are the permanent physical IDs of your network card.\u003C/li>\n\u003Cli>\u003Cstrong>The EtherType:\u003C/strong> This is a crucial 2-byte field. It tells my sniffer: “Hey, the next layer inside me is an IPv4 packet” (Value \u003Ccode>8\u003C/code>) or “This is an ARP request” (Value \u003Ccode>2054\u003C/code>).\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"2-the-ip-packet-the-routing-layer\">2. The IP Packet (The Routing Layer)\u003C/h3>\n\u003Cp>Once we peel back the Ethernet header, we find the \u003Cstrong>Internet Protocol (IP)\u003C/strong> packet. This is the “envelope” used to move data across the wider internet.\u003C/p>\n\u003Cul>\n\u003Cli>\u003Cstrong>IP Addresses:\u003C/strong> The logical Source and Destination (e.g., \u003Ccode>192.168.1.1\u003C/code>).\u003C/li>\n\u003Cli>\u003Cstrong>TTL (Time to Live):\u003C/strong> A counter that prevents packets from looping forever.\u003C/li>\n\u003Cli>\u003Cstrong>Protocol Field:\u003C/strong> Just like the EtherType, this tells us what’s inside the IP packet—TCP, UDP, or ICMP.\u003C/li>\n\u003C/ul>\n\u003Ch3 id=\"3-the-transport-protocols-the-engines\">3. The Transport Protocols (The Engines)\u003C/h3>\n\u003Cp>This is where the actual “work” happens. NetSniff is designed to handle the “Big Three”:\u003C/p>\n\u003Cul>\n\u003Cli>\u003Cstrong>TCP (Transmission Control Protocol):\u003C/strong> The “Reliable” one. It uses a 3-way handshake. My code extracts \u003Cstrong>Flags\u003C/strong> (URG, ACK, PSH, RST, SYN, FIN) to show if a connection is starting, ending, or resetting.\u003C/li>\n\u003Cli>\u003Cstrong>UDP (User Datagram Protocol):\u003C/strong> The “Fast” one. No handshakes, just raw data. Great for streaming or DNS.\u003C/li>\n\u003Cli>\u003Cstrong>ICMP (Internet Control Message Protocol):\u003C/strong> The “Diagnostic” one. This is what \u003Ccode>ping\u003C/code> uses to check if a server is alive.\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Ch2 id=\"flow-code-architecture\">Flow: Code Architecture\u003C/h2>\n\u003Cp>\u003Cimg __ASTRO_IMAGE_=\"{&#x22;src&#x22;:&#x22;../../assets/blog/NetSniff_Flow.excalidraw.png&#x22;,&#x22;alt&#x22;:&#x22;NetSniff Flow&#x22;,&#x22;index&#x22;:0}\">\u003C/p>\n\u003Chr>\n\u003Ch2 id=\"technical-hurdles-bitwise-operations\">Technical Hurdles: Bitwise Operations\u003C/h2>\n\u003Cp>One of the most challenging parts of this project was dealing with \u003Cstrong>Network Byte Order (Big Endian)\u003C/strong>. Computers store data differently than networks transmit it.\u003C/p>\n\u003Cp>I used Python’s \u003Ccode>struct\u003C/code> module to map binary data to variables. For example, the IP version and Header Length are crammed into a single byte. To separate them, I had to use \u003Cstrong>Bitwise Shifting\u003C/strong>:\u003C/p>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan>version_header_length = data[0]\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>version = version_header_length >> 4  # Shift right 4 bits to get the version\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan>header_length = (version_header_length &#x26; 15) * 4  # Use a mask to get the length\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Chr>\n\u003Ch2 id=\"intelligent-data-handling-the-buffer-system\">Intelligent Data Handling: The Buffer System\u003C/h2>\n\u003Cp>Writing to a CSV file is a “slow” operation for a computer. If your network is busy, the sniffer might miss a packet while it’s busy writing the previous one to the disk.\u003C/p>\n\u003Cp>To solve this, I implemented a \u003Cstrong>Buffer Strategy\u003C/strong>:\u003C/p>\n\u003Col>\n\u003Cli>\u003Cstrong>List Storage:\u003C/strong> Packets are held in a memory-resident list.\u003C/li>\n\u003Cli>\u003Cstrong>Batch Processing:\u003C/strong> Only when the list hits 50 packets does the \u003Ccode>pandas\u003C/code> library trigger a write to the CSV.\u003C/li>\n\u003Cli>\u003Cstrong>Schema Consistency:\u003C/strong> Since an ARP packet has different fields than a TCP packet, I used a \u003Ccode>base_fields\u003C/code> dictionary to ensure the CSV columns stay perfectly aligned, even when data is missing.\u003C/li>\n\u003C/ol>\n\u003Chr>\n\u003Ch2 id=\"quick-start-guide\">Quick Start Guide\u003C/h2>\n\u003Cp>Want to try NetSniff yourself? Follow these steps:\u003C/p>\n\u003Col>\n\u003Cli>\u003Cstrong>Clone:\u003C/strong> clone the repository from \u003Cstrong>\u003Ca href=\"https://github.com/5yndr0m/netsniff\">GitHub\u003C/a>\u003C/strong>\u003C/li>\n\u003Cli>\u003Cstrong>Environment:\u003C/strong> Create a virtual environment to keep your system clean.\u003C/li>\n\u003C/ol>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"bash\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#B392F0\">python\u003C/span>\u003Cspan style=\"color:#79B8FF\"> -m\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> venv\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> venv\u003C/span>\u003C/span>\n\u003Cspan class=\"line\">\u003Cspan style=\"color:#79B8FF\">source\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> venv/bin/python\u003C/span>\u003Cspan style=\"color:#6A737D\">  # On Linux\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Col start=\"2\">\n\u003Cli>\u003Cstrong>Script:\u003C/strong> Copy the \u003Ccode>netsniff.py\u003C/code> into the virtual environment.\u003C/li>\n\u003Cli>\u003Cstrong>Dependencies:\u003C/strong> You’ll need \u003Ccode>pandas\u003C/code> for the data export.\u003C/li>\n\u003C/ol>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"bash\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#B392F0\">pip\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> install\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> pandas\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Col start=\"4\">\n\u003Cli>\u003Cstrong>Execution:\u003C/strong> Because we are touching Raw Sockets, you \u003Cstrong>must\u003C/strong> use \u003Ccode>sudo\u003C/code>.\u003C/li>\n\u003C/ol>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"bash\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#B392F0\">sudo\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> ./venv/bin/python\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> netsniff.py\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Col start=\"5\">\n\u003Cli>\u003Cstrong>Logs:\u003C/strong> To get terminal logs you can add \u003Ccode>--verbose\u003C/code> flag.\u003C/li>\n\u003C/ol>\n\u003Cpre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"bash\">\u003Ccode>\u003Cspan class=\"line\">\u003Cspan style=\"color:#B392F0\">sudo\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> ./venv/bin/python\u003C/span>\u003Cspan style=\"color:#9ECBFF\"> netsniff.py\u003C/span>\u003Cspan style=\"color:#79B8FF\"> --verbose\u003C/span>\u003C/span>\u003C/code>\u003C/pre>\n\u003Col start=\"7\">\n\u003Cli>\u003Cstrong>Output:\u003C/strong> Sniffed packets will be saved to the \u003Ccode>capture_data.csv\u003C/code> file in the same directory\u003C/li>\n\u003C/ol>\n\u003Chr>\n\u003Ch2 id=\"troubleshooting--faq\">Troubleshooting &#x26; FAQ\u003C/h2>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Cstrong>“Why do I get Permission Denied?”\u003C/strong>\u003C/p>\n\u003Cp>Raw sockets allow you to see traffic from other users and the OS. For security reasons, Linux requires \u003Ccode>sudo\u003C/code> or \u003Ccode>CAP_NET_RAW\u003C/code> privileges to run this.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>“I’m on Windows and it’s crashing!”\u003C/strong>\u003C/p>\n\u003Cp>This specific implementation uses \u003Ccode>AF_PACKET\u003C/code>, which is a Linux-specific socket type. For Windows support, one would typically use \u003Ccode>WinPcap\u003C/code> or \u003Ccode>Npcap\u003C/code> drivers.\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Cstrong>“Why is the CSV empty?”\u003C/strong>\u003C/p>\n\u003Cp>The sniffer waits for 50 packets before saving. If your network is quiet, try browsing a few websites to generate traffic, or hit \u003Ccode>Ctrl+C\u003C/code> to force a final save of the remaining buffer.\u003C/p>\n\u003C/li>\n\u003C/ul>\n\u003Chr>\n\u003Cp>\u003Cstrong>This project was a deep dive into the “low level” of the web. What should I sniff next? Maybe an HTTP traffic decrypter?\u003C/strong>\u003C/p>",{"headings":29,"localImagePaths":62,"remoteImagePaths":63,"frontmatter":64,"imagePaths":66},[30,34,37,41,44,47,50,53,56,59],{"depth":31,"slug":32,"text":33},2,"what-exactly-is-a-sniffer","What exactly is a “Sniffer”?",{"depth":31,"slug":35,"text":36},"the-anatomy-of-the-network-onion","The Anatomy of the Network “Onion”",{"depth":38,"slug":39,"text":40},3,"1-the-ethernet-frame-the-outer-shell","1. The Ethernet Frame (The Outer Shell)",{"depth":38,"slug":42,"text":43},"2-the-ip-packet-the-routing-layer","2. The IP Packet (The Routing Layer)",{"depth":38,"slug":45,"text":46},"3-the-transport-protocols-the-engines","3. The Transport Protocols (The Engines)",{"depth":31,"slug":48,"text":49},"flow-code-architecture","Flow: Code Architecture",{"depth":31,"slug":51,"text":52},"technical-hurdles-bitwise-operations","Technical Hurdles: Bitwise Operations",{"depth":31,"slug":54,"text":55},"intelligent-data-handling-the-buffer-system","Intelligent Data Handling: The Buffer System",{"depth":31,"slug":57,"text":58},"quick-start-guide","Quick Start Guide",{"depth":31,"slug":60,"text":61},"troubleshooting--faq","Troubleshooting & FAQ",[22,23],[],{"title":14,"description":15,"pubDate":65,"heroImage":24,"category":18},["Date","2026-02-04T00:00:00.000Z"],[22,23],"Decoding the Wire.md"]